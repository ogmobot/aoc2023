       IDENTIFICATION DIVISION.
       PROGRAM-ID. DAY25.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT PUZZLE-INPUT ASSIGN TO "input25.txt"
      *    GNU COBOL ALLOWS "LINE SEQUENTIAL" MODE
           ORGANIZATION IS LINE SEQUENTIAL
           FILE STATUS IS PUZZLE-FS.

       DATA DIVISION.
       FILE SECTION.
           FD PUZZLE-INPUT.
      *LONGEST LINE IN FILE IS 41 CHARS (INCL. NEWLINE)
       01 PUZZLE-LINE PIC X(64).

       WORKING-STORAGE SECTION.
           01 PUZZLE-IO.
             03 PUZZLE-FS PIC 9(2).
             03 PUZZLE-EOF PIC 9(1).
           01 LINE-INDEX PIC 9(2).

           01 INITIAL-EDGE-COUNT PIC 9(4).
           01 EDGE-COUNT PIC 9(4).
      *    TOTAL WEIGHT OF ALL REMAINING EDGES. THIS IS INITIALLY EQUAL
      *    TO THE NUMBER OF EDGES, BUT DECREASES AS EDGES ARE REMOVED.
           01 TOTAL-WEIGHT PIC 9(4).

           01 RANDOM-OFFSET PIC S9(4).

      *    BEWARE -- TABLES ARE 1-INDEXED!
      *    THIS TABLE GETS MANGLED.
           01 EDGE-TABLE.
             03 EDGE-RECORD OCCURS 9999 TIMES INDEXED BY EDGE-INDEX.
               05 FIRST-NODE PIC A(3).
               05 SECOND-NODE PIC A(3).
               05 EDGE-WEIGHT PIC 9(4).
      *    FOR EXAMPLE, THE LINE "ABC: DEF GHI"
      *    CREATES THE EDGES {"ABC" "DEF" 0001} AND {"ABC" "GHI" 0001}.
           01 INDEX-I PIC S9(9).
           01 INDEX-J PIC S9(9).

           01 ORIGINAL-EDGE-TABLE.
             03 ORIGINAL-RECORD OCCURS 9999 TIMES.
               05 O-FIRST-NODE PIC A(3).
               05 O-SECOND-NODE PIC A(3).
               05 O-EDGE-WEIGHT PIC 9(4).

           01 TEMP-EDGE.
             03 TEMP-FIRST-NODE PIC A(3).
             03 TEMP-SECOND-NODE PIC A(3).
             03 TEMP-EDGE-WEIGHT PIC 9(4).

      *    KEEPS TRACK OF THE SIZE OF EACH CLUSTER OF NODES.
           01 NODE-SIZES.
             03 SIZE-RECORD OCCURS 9999 TIMES INDEXED BY SIZE-INDEX.
               05 NODE-ID PIC A(3).
               05 NODE-SIZE PIC 9(4).
           01 MAX-SIZE-INDEX PIC 9(4).

           01 TEMP-BOOL PIC 9.
           01 SOLUTION PIC 9(6).

       PROCEDURE DIVISION.
      *TAKES 21 ATTEMPTS, AT ~32 S PER ATTEMPT; TOTAL ~11 MIN
      *(RANDOM SEED IS FIXED, SO NUMBER OF ATTEMPTS WON'T CHANGE.)
       MAIN.
           PERFORM LOAD-INPUT-FILE.
           SET SOLUTION TO ZERO.
           PERFORM UNTIL EDGE-WEIGHT (1) IS EQUAL TO 3
             ADD 1 TO SOLUTION END-ADD
             DISPLAY "ATTEMPTING CUT " SOLUTION END-DISPLAY
             PERFORM ATTEMPT-RANDOM-CUT
             DISPLAY "DONE. GOT EDGE:" END-DISPLAY
             DISPLAY EDGE-RECORD (1) END-DISPLAY
      *      STOP RUN
           END-PERFORM.
           PERFORM CONVERT-TO-SOLUTION.
           DISPLAY SOLUTION END-DISPLAY.
           STOP RUN.

       LOAD-INPUT-FILE.
           SET PUZZLE-EOF TO ZERO.
           SET INITIAL-EDGE-COUNT TO ZERO.
           SET EDGE-INDEX TO 1.
           OPEN INPUT PUZZLE-INPUT.
           PERFORM UNTIL PUZZLE-EOF IS EQUAL TO 1
             READ PUZZLE-INPUT
               INTO PUZZLE-LINE
      *        THIS GENERATES A WARNING SINCE IN THEORY LINES ARE LONG
               AT END SET PUZZLE-EOF TO 1
               END-READ
             IF PUZZLE-EOF IS EQUAL TO ZERO THEN
               PERFORM LINE-TO-EDGES
             END-IF
           END-PERFORM.
           CLOSE PUZZLE-INPUT.

       LINE-TO-EDGES.
      *    MAKES A LOT OF ASSUMPTIONS ABOUT INPUT'S SPACING!
      *    MOVE LINE-INDEX TO FIRST CONNECTEE
           SET LINE-INDEX TO 6.
           PERFORM UNTIL PUZZLE-LINE (LINE-INDEX:3) IS EQUAL TO SPACES
             MOVE PUZZLE-LINE (1:3)
               TO O-FIRST-NODE (EDGE-INDEX)
             MOVE PUZZLE-LINE (LINE-INDEX:3)
               TO O-SECOND-NODE (EDGE-INDEX)
             MOVE 0001 TO O-EDGE-WEIGHT (EDGE-INDEX)
      *      DISPLAY ORIGINAL-RECORD (EDGE-INDEX) END-DISPLAY
      *      MOVE LINE-INDEX TO NEXT CONNECTEE (OR END OF LINE)
             ADD 4 TO LINE-INDEX END-ADD
             ADD 1 TO EDGE-INDEX END-ADD
             ADD 1 TO INITIAL-EDGE-COUNT END-ADD
           END-PERFORM.

       RESET-EDGES.
      *    ALSO RESETS NODE SIZES
           MOVE ORIGINAL-EDGE-TABLE TO EDGE-TABLE.
           SET EDGE-COUNT TO INITIAL-EDGE-COUNT.
           SET TOTAL-WEIGHT TO INITIAL-EDGE-COUNT.
           SET MAX-SIZE-INDEX TO ZERO.

       ATTEMPT-RANDOM-CUT.
           PERFORM RESET-EDGES.
           PERFORM UNTIL EDGE-COUNT IS EQUAL TO 1
             PERFORM GET-RANDOM-EDGE
      *      DISPLAY "RANDOM EDGE:" END-DISPLAY
      *      DISPLAY EDGE-RECORD (EDGE-INDEX) END-DISPLAY
             PERFORM MERGE-NODES
           END-PERFORM.
 
       GET-RANDOM-EDGE.
      *    SETS EDGE-INDEX.
      *    CHOOSE A RANDOM OFFSET BETWEEN 0 AND TOTAL-WEIGHT-1
           COMPUTE RANDOM-OFFSET =
             TOTAL-WEIGHT * FUNCTION RANDOM
             END-COMPUTE.
           SET EDGE-INDEX TO ZERO.
      *    SELECT EDGE BY LOOPING UNTIL THAT OFFSET IS ZERO OR LESS
           PERFORM UNTIL RANDOM-OFFSET IS LESS THAN ZERO
             SUBTRACT EDGE-WEIGHT (EDGE-INDEX + 1) FROM RANDOM-OFFSET
               END-SUBTRACT
             ADD 1 TO EDGE-INDEX END-ADD
      *      DISPLAY RANDOM-OFFSET END-DISPLAY
           END-PERFORM.

       MERGE-NODES.
      *    MERGES THE NODES JOINED BY THE EDGE AT EDGE-INDEX.
      *    THE NEW NODE IS FIRST-NODE (EDGE-INDEX).
      *    DISPLAY "EDGE COUNT: " EDGE-COUNT END-DISPLAY.
      *    DISPLAY "MERGING NODES: "
      *      EDGE-RECORD (EDGE-INDEX) " AT " EDGE-INDEX END-DISPLAY.
           PERFORM UPDATE-NODE-SIZE.
      *    DELETE THE EDGE AT INDEX EDGE-COUNT
           MOVE EDGE-RECORD (EDGE-INDEX) TO TEMP-EDGE.
           SUBTRACT EDGE-WEIGHT (EDGE-INDEX) FROM TOTAL-WEIGHT
             END-SUBTRACT.
           MOVE EDGE-RECORD (EDGE-COUNT) TO EDGE-RECORD (EDGE-INDEX).
           SUBTRACT 1 FROM EDGE-COUNT END-SUBTRACT.

           SET INDEX-I TO ZERO.
           PERFORM UNTIL INDEX-I IS GREATER THAN EDGE-COUNT
      *      FIND EACH EDGE ATTACHED TO SECOND-NODE.
      *      SET INDEX-I TO POINT AT SUCH AN EDGE:
             PERFORM FIND-CONNECTING-EDGE
             IF INDEX-I IS NOT GREATER THAN EDGE-COUNT THEN
      *        POINT IT TO FIRST-NODE INSTEAD.
      *        DISPLAY "FOUND CONNECTING EDGE: "
      *         EDGE-RECORD (INDEX-I) " AT " INDEX-I END-DISPLAY
               IF FIRST-NODE (INDEX-I) IS EQUAL TO
                  TEMP-SECOND-NODE THEN
                 MOVE TEMP-FIRST-NODE TO FIRST-NODE (INDEX-I)
               ELSE
                 MOVE TEMP-FIRST-NODE TO SECOND-NODE (INDEX-I)
               END-IF
      *        DISPLAY "CHANGED TO: " EDGE-RECORD (INDEX-I) END-DISPLAY
      *        IF THIS CREATES A DUPLICATE EDGE,
      *        DELETE ONE EDGE AND ADJUST THE OTHER'S WEIGHT.
               PERFORM FIND-DUPLICATE-EDGE
               IF INDEX-J IS NOT GREATER THAN EDGE-COUNT THEN
      *          DISPLAY "FOUND DUPLICATE EDGE: "
      *            EDGE-RECORD (INDEX-J) END-DISPLAY
                 ADD EDGE-WEIGHT (INDEX-J) TO EDGE-WEIGHT (INDEX-I)
                   END-ADD
      *          DELETE EDGE AT INDEX-J
                 MOVE EDGE-RECORD (EDGE-COUNT) TO EDGE-RECORD (INDEX-J)
                 SUBTRACT 1 FROM EDGE-COUNT END-SUBTRACT
      *          DISPLAY "NEW: " EDGE-RECORD (INDEX-I) END-DISPLAY
      *          DELETING INDEX-J MIGHT HAVE SWAPPED IN A NEW EDGE
      *          THAT NEEDS TO BE MODIFIED.
                 IF INDEX-J IS LESS THAN INDEX-I THEN
                   SUBTRACT 1 FROM INDEX-J GIVING INDEX-I END-SUBTRACT
                 END-IF
               END-IF
             END-IF
           END-PERFORM.

       UPDATE-NODE-SIZE.
      *    UPDATE THE SIZE OF FIRST-NODE (EDGE-INDEX) WHEN IT IS MERGED
      *    WITH SECOND-NODE (EDGE-INDEX).
           SET INDEX-I TO ZERO.
           SET INDEX-J TO ZERO.
           SET SIZE-INDEX TO ZERO.
           PERFORM UNTIL INDEX-I IS GREATER THAN ZERO
                   AND INDEX-J IS GREATER THAN ZERO
             ADD 1 TO SIZE-INDEX END-ADD
             IF SIZE-INDEX IS GREATER THAN MAX-SIZE-INDEX THEN
               IF INDEX-I IS EQUAL TO ZERO
                 ADD 1 TO MAX-SIZE-INDEX END-ADD
                 SET INDEX-I TO SIZE-INDEX
                 MOVE FIRST-NODE (EDGE-INDEX) TO NODE-ID (SIZE-INDEX) 
                 SET NODE-SIZE (SIZE-INDEX) TO 1
               ELSE
      *          NO NEED TO SET THIS UP, SINCE IT'LL MERGE ANYWAY
                 SET INDEX-J TO SIZE-INDEX
                 SET NODE-SIZE (SIZE-INDEX) TO 1
               END-IF
             ELSE
               IF FIRST-NODE (EDGE-INDEX) IS EQUAL TO
                  NODE-ID (SIZE-INDEX) THEN
                 SET INDEX-I TO SIZE-INDEX
               END-IF
               IF SECOND-NODE (EDGE-INDEX) IS EQUAL TO
                  NODE-ID (SIZE-INDEX) THEN
                 SET INDEX-J TO SIZE-INDEX
               END-IF
             END-IF
           END-PERFORM.
      *    DISPLAY "OLD SIZES " NODE-SIZE (INDEX-I)
      *      " AND " NODE-SIZE (INDEX-J) END-DISPLAY.
           ADD NODE-SIZE (INDEX-J) TO NODE-SIZE (INDEX-I) END-ADD.
      *    DISPLAY "NEW SIZE " NODE-SIZE (INDEX-I) END-DISPLAY.

       FIND-CONNECTING-EDGE.
      *    ADVANCES INDEX-I UNTIL EDGE-RECORD (INDEX-I) CONNECTS
      *      TO THE NODE TEMP-SECOND-NODE, BUT IS NOT
      *      THE SAME INDEX; OR UNTIL INDEX-I EXCEEDS
      *      EDGE-COUNT.
           SET TEMP-BOOL TO ZERO.
           PERFORM UNTIL TEMP-BOOL IS EQUAL TO 1
             ADD 1 TO INDEX-I END-ADD
      *      SELECT THIS EDGE IF EITHER OF ITS NODES MATCHES
             IF INDEX-I IS GREATER THAN EDGE-COUNT THEN
               SET TEMP-BOOL TO 1
             ELSE
               IF FIRST-NODE (INDEX-I) IS EQUAL TO
                  TEMP-SECOND-NODE THEN
                 SET TEMP-BOOL TO 1
               END-IF
               IF SECOND-NODE (INDEX-I) IS EQUAL TO
                  TEMP-SECOND-NODE THEN
                 SET TEMP-BOOL TO 1
               END-IF
             END-IF
           END-PERFORM.

       FIND-DUPLICATE-EDGE.
      *    ADVANCES INDEX-J UNTIL EDGE-RECORD (INDEX-I) AND
      *      EDGE-RECORD (INDEX-J) CONNECT TO THE SAME NODES
      *      (BUT I != J) OR UNTIL INDEX-J EXCEEDS EDGE-COUNT.
           SET TEMP-BOOL TO ZERO.
           SET INDEX-J TO ZERO.
           PERFORM UNTIL TEMP-BOOL IS EQUAL TO 1
             ADD 1 TO INDEX-J END-ADD
             IF INDEX-J IS GREATER THAN EDGE-COUNT THEN
               SET TEMP-BOOL TO 1
             ELSE
               IF FIRST-NODE (INDEX-I) IS EQUAL TO
                  FIRST-NODE (INDEX-J)
                 AND SECOND-NODE (INDEX-I) IS EQUAL TO
                     SECOND-NODE (INDEX-J) THEN
                 SET TEMP-BOOL TO 1
               END-IF
               IF FIRST-NODE (INDEX-I) IS EQUAL TO
                  SECOND-NODE (INDEX-J)
                 AND SECOND-NODE (INDEX-I) IS EQUAL TO
                     FIRST-NODE (INDEX-J) THEN
                 SET TEMP-BOOL TO 1
               END-IF
      *        BUT IF IT'S AN INVALID EDGE, IGNORE IT!
               IF INDEX-J IS EQUAL TO INDEX-I THEN
                 SET TEMP-BOOL TO ZERO
               END-IF
             END-IF
           END-PERFORM.

       CONVERT-TO-SOLUTION.
      *    SETS SOLUTION.
      *    FINDS THE SIZES OF FIRST-NODE (1) AND
      *    SECOND-NODE (1) AND MULTIPLIES THEM TOGETHER.
           SET SIZE-INDEX TO ZERO.
           SET INDEX-I TO ZERO.
           SET INDEX-J TO ZERO.
           PERFORM UNTIL INDEX-I IS GREATER THAN ZERO
                   AND INDEX-J IS GREATER THAN ZERO
             ADD 1 TO SIZE-INDEX END-ADD
             IF FIRST-NODE (1) IS EQUAL TO
                NODE-ID (SIZE-INDEX) THEN
               SET INDEX-I TO SIZE-INDEX
             END-IF
             IF SECOND-NODE (1) IS EQUAL TO
                NODE-ID (SIZE-INDEX) THEN
               SET INDEX-J TO SIZE-INDEX
             END-IF
           END-PERFORM.
           DISPLAY NODE-SIZE (INDEX-I) END-DISPLAY
           DISPLAY NODE-SIZE (INDEX-J) END-DISPLAY
           MULTIPLY NODE-SIZE (INDEX-J) BY
                    NODE-SIZE (INDEX-I) GIVING
                    SOLUTION
                    END-MULTIPLY.
